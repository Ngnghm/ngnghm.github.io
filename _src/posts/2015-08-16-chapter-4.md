    Title: Chapter 4: Minding Your Turtles
    Date: 2015-08-16T01:10:00
    Tags: DRAFT

Ngnghm wanted to know how Humans dealt with Persistence.
He found that we were using a large quantity of libraries to each implement some aspect of persistence,
and was not impressed.
I asked him what Houyhnhnms used instead.
He told me that persistence was always a given,
and instead that had a number of libraries to deal with transience.



<!-- more -->


### Building up vs building down

Ngnghm hadn’t noticed at first this essential transience of all data in Human computer systems.
Any and all of Human data may disappear at any time without notice.
To prevent or mitigate this loss, Humans have to explicitly take extraordinary steps
to save all kinds of data, regularly, with rigorous discipline.
Each bit of data requires its own special steps to save and sometimes much harder to restore
— if by a combination of bad luck yet good preparation some Humans lost their data
but possessed some form of a backup.
And that there exists no imaginable mechanism to restore data in a coherent way
across several software or hardware components,
making the restoration of a simple terminal user’s computer a hard task,
and that of an actual live service a heroic feat.

Moreover, all data was bound to disappear eventually.
Not only hardware, but also software, was often expected to be used until it failed,
with no regular plan to transfer data to a replacement system until it had at least started to fail.
Human applications are written in an extremely fragile way,
where persistence and correctness are considered “non-functional” requirements
and are dealt with as an afterthought.
Therefore, it is expected that applications will crash,
have a race condition with other applications, experience plain old bugs,
or be subject to vulnerabilities,
at which point users will irremediably lose configuration or session data,
documents written or data entered.
(Interestingly, while it is all too easy for data you care about to be deleted,
yet it is very hard to make sure that some data you want forgotten is ever completely deleted.)

Human computer systems have an inordinate amount of mutually incompatible “libraries”
meant to deal with “file formats”, “serialization protocols”, “marshalling”, “markup languages”,
“interchange formats”, “memory layout”, “database schema”, “database servers”,
“query languages”, “object relational mapping”, “foreign function interface”, etc.
In each of these categories, the offering consists in plenty of software projects,
all of them mutually incompatible and somewhat fragile.

Hence, Houyhnhnms don’t have any library to manage persistence.
Instead, Houyhnhnms have a number of libraries to manage transience.

Delivering software as components, not applications (Human closest: browser plugins)

Humans can only build but _up_. Houyhnhnms can build both up _and_ down.

Always jump into the "top" (bottom) universe and rebase reality.

Houyhnhnms implement _strategies_ that can then be applied.

Like Urbit JETs, except now built into the system, but selectable by users.
Urbit is still a "build upwards only" system.

Inconsistent strategies can cause inconsistent behavior,
but only within the narrow scope that adopted them.

Towers and Stacks


Humans have large and complex libraries to fake persistence on top of essential transience at every level.
Houyhnhnms consider persistence a basic system property at every level,
and have relatively simple libraries to escape into transience
where performance or fine-grained semantics (or system bootstrap) calls for it.
Humans have many devices that they connect into networks, where bits are copied.
Houyhnhnms have a single system that they subdivide into domains,
between which data is distributed (more like [Urbit](http://moronlab.blogspot.com/2010/01/urbit-functional-programming-from.html)).

Not only does that make Houyhnhnm systems much simpler,
it also guarantees forever interoperability of every single piece data with any future system,
at whichever level of abstraction that data was defined.
If you want your data to remain relevant to your future self, or to be usable by other people, etc.,
you still need to wisely choose suitable algebraic data types,
to organize software into components with clean interfaces,
to pick appropriate policies that lead to suitably performant implementations,
to rely on suitable libraries.


### Adding turtles below

Human computer systems start from a given base, and build up.
Slightly more advanced Human computer systems, using macros,
can at compile time lift the system up and add a number of layers below.
(For an extreme case, see Common Lisp in Common Lisp implementations
used to add first-class continuations, sometimes also serializable,
so as to enable backtracking and/or continuation-based web programming.)
Some interactive development systems also instrument the virtual machine
so as to lift execution into something that allows for debugging.
But even then, once the program is built, once the runtime has been chosen,
once the program has started running,
the system remains forever grounded on top of the chosen basis.
Houyhnhnm computer systems, by contrast,
can dynamically add new layers below a running program.
Add a turtle beneath the existing stack of turtles,
and lifting the entire stack of turtles, while the system is running.
